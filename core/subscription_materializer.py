from datetime import datetime, timedelta
from django.utils import timezone
from django.db import transaction
from .models import StripeSubscriptionSchedule, Service, Booking
import logging

log = logging.getLogger(__name__)

# Default planning horizon (~12 weeks)
HORIZON_WEEKS = 12


def _find_or_create_open_invoice(client):
    """
    Find an existing open/draft invoice for the client, or create a new one.
    Returns the invoice ID or None if Stripe is not configured.
    """
    try:
        from .stripe_integration import find_or_create_draft_invoice
        return find_or_create_draft_invoice(client)
    except Exception as e:
        log.warning("Could not find/create invoice for client %s: %s", client.id, e)
        return None


def _monday_of_week(dt):
    """Get the Monday of the week containing dt."""
    return dt - timedelta(days=dt.weekday())


def _ensure_tz(dt):
    """Keep naive as-is if the app is naive; if aware, attach timezone."""
    if timezone.is_naive(dt):
        return timezone.make_aware(dt, timezone.get_current_timezone())
    return dt


def _plan_slots(sched, week0, horizon_weeks):
    """
    Yield (start_dt, end_dt, service) tuples for each planned slot in the horizon.
    """
    service = Service.objects.filter(code=sched.sub.service_code, is_active=True).first()
    if not service or not service.duration_minutes:
        return
    days = sched.parsed_days()
    t = sched.parsed_time()
    interval = sched.interval_weeks()  # 1 = weekly, 2 = fortnightly
    for wk in range(0, horizon_weeks, interval):
        week_start = week0 + timedelta(weeks=wk)
        for d in days:
            day_dt = week_start + timedelta(days=d)  # 0=Mon
            start_dt = datetime(day_dt.year, day_dt.month, day_dt.day, t.hour, t.minute)
            start_dt = _ensure_tz(start_dt)
            end_dt = start_dt + timedelta(minutes=service.duration_minutes)
            yield start_dt, end_dt, service


def _delete_future_autogen_for_schedule(sched, cutoff_dt):
    """
    Only delete future, autogenerated bookings owned by this schedule.
    Do not touch manual bookings or past bookings.
    """
    qs = Booking.objects.filter(
        schedule=sched,
        autogenerated=True,
        start_dt__gte=cutoff_dt,
    )
    deleted_count = qs.count()
    qs.delete()
    return deleted_count


@transaction.atomic
def materialize_for_schedule(sched: StripeSubscriptionSchedule, now_dt=None, horizon_weeks=HORIZON_WEEKS):
    """
    Deterministically (re)build future bookings for a single schedule.
    Strategy:
      - If inactive: delete future autogenerated bookings and stop.
      - If incomplete or invalid service/duration: skip (no deletions).
      - Else: delete future autogenerated, then re-create exact plan.
      - Never overwrite or delete manual bookings.
      - Include open invoices when materializing bookings.
    Returns dict with counts.
    """
    now_dt = now_dt or timezone.localtime()
    week0 = _monday_of_week(now_dt)

    # Inactive schedules stop producing new bookings; remove future autogenerated
    if not sched.sub.active:
        removed = _delete_future_autogen_for_schedule(sched, week0)
        log.info("Sched %s inactive â†’ removed future autogenerated=%s", sched.id, removed)
        return {"created": 0, "skipped": 0, "removed": removed}

    # Require completeness and valid service
    if not sched.is_complete():
        log.info("Skip sched %s: incomplete (%s)", sched.id, ",".join(sched.missing_fields()))
        return {"created": 0, "skipped": 0, "removed": 0}
    service = Service.objects.filter(code=sched.sub.service_code, is_active=True).first()
    if not service or not service.duration_minutes:
        log.info("Skip sched %s: service missing/invalid duration", sched.id)
        return {"created": 0, "skipped": 0, "removed": 0}

    removed = _delete_future_autogen_for_schedule(sched, week0)
    created = 0
    skipped = 0
    location = sched.location or "Home"
    
    # Try to find or create an open invoice for this client
    invoice_id = _find_or_create_open_invoice(sched.sub.client)

    for start_dt, end_dt, svc in _plan_slots(sched, week0, horizon_weeks):
        # If any booking exists at this slot (manual or autogenerated), skip creation
        if Booking.slot_exists(sched.sub.client, start_dt, service=svc):
            skipped += 1
            continue
        Booking.objects.create(
            client=sched.sub.client,
            service=svc,
            service_code=sched.sub.service_code,
            service_name=svc.name,
            service_label=svc.name,
            start_dt=start_dt,
            end_dt=end_dt,
            price_cents=0,
            status="pending",
            location=location,
            schedule=sched,
            autogenerated=True,
            stripe_invoice_id=invoice_id,  # Link to open invoice if available
        )
        created += 1

    log.info("Sched %s materialized: created=%s skipped=%s removed=%s", sched.id, created, skipped, removed)
    return {"created": created, "skipped": skipped, "removed": removed}


@transaction.atomic
def materialize_all(now_dt=None, horizon_weeks=HORIZON_WEEKS):
    """
    Rebuild future bookings for all schedules in a deterministic way.
    """
    now_dt = now_dt or timezone.localtime()
    totals = {"created": 0, "skipped": 0, "removed": 0, "processed": 0}
    for sched in StripeSubscriptionSchedule.objects.all().select_related("sub__client"):
        res = materialize_for_schedule(sched, now_dt=now_dt, horizon_weeks=horizon_weeks)
        for k in ("created", "skipped", "removed"):
            totals[k] += res.get(k, 0)
        totals["processed"] += 1
    log.info("Materialize all: %s", totals)
    return totals


# Backward compatibility alias
@transaction.atomic
def materialize_future_holds(now_dt=None):
    """
    Legacy function name for backward compatibility.
    Delegates to materialize_all().
    """
    return materialize_all(now_dt=now_dt, horizon_weeks=8)
