import logging
import json
import stripe
from django.http import HttpResponse, HttpResponseBadRequest, HttpResponseForbidden
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_POST
from django.conf import settings
from django.utils.timezone import localtime
from .stripe_invoices_sync import process_invoice
from .subscription_materializer import materialize_for_schedule
from .models import StripeSubscriptionLink, StripeSubscriptionSchedule
from .audit import emit as audit_emit

log = logging.getLogger(__name__)

@csrf_exempt
@require_POST
def stripe_webhook(request):
    payload = request.body
    sig_header = request.META.get("HTTP_STRIPE_SIGNATURE")
    secret = getattr(settings, "STRIPE_WEBHOOK_SECRET", None)
    event = None
    # Verify signature if secret configured; otherwise parse JSON and proceed (dev mode)
    if secret:
        try:
            event = stripe.Webhook.construct_event(payload=payload, sig_header=sig_header, secret=secret)
        except Exception as e:
            log.warning("Stripe signature verification failed: %s", e)
            return HttpResponseForbidden("invalid signature")
    else:
        try:
            event = json.loads(payload.decode("utf-8"))
        except Exception:
            return HttpResponseBadRequest("invalid payload")

    etype = event["type"] if isinstance(event, dict) else getattr(event, "type", None)
    obj = event["data"]["object"] if isinstance(event, dict) else getattr(getattr(event, "data", None), "object", None)

    # ---- Invoice events ----
    if etype in ("invoice.finalized", "invoice.paid", "invoice.payment_failed"):
        try:
            res = process_invoice(obj)
            log.info("Webhook %s processed invoice %s: %s", etype, getattr(obj, "id", None) or obj.get("id"), res)
            audit_emit(
                "webhook.invoice",
                message=f"{etype} processed",
                actor=None,
                booking=None,
                context={"invoice_id": getattr(obj, 'id', None) or obj.get('id'), "result": res},
            )
        except Exception as e:
            # Never 5xx â€” we rely on poller as fallback
            log.exception("Webhook %s failed for invoice %s: %s", etype, getattr(obj, "id", None), e)
        return HttpResponse("ok")

    # ---- Subscription events ----
    if etype in ("customer.subscription.updated", "customer.subscription.deleted"):
        sub_id = getattr(obj, "id", None) or obj.get("id")
        status = getattr(obj, "status", None) or obj.get("status")
        link = StripeSubscriptionLink.objects.filter(stripe_subscription_id=sub_id).first()
        if not link:
            log.info("Webhook %s: no local link for sub %s", etype, sub_id)
            return HttpResponse("ok")
        sched = StripeSubscriptionSchedule.objects.filter(sub__stripe_subscription_id=sub_id).first()
        if not sched:
            log.info("Webhook %s: no schedule for sub %s", etype, sub_id)
            return HttpResponse("ok")
        try:
            if etype == "customer.subscription.deleted" or (status and status in ("canceled", "incomplete_expired")):
                # deactivate schedule and remove future autogenerated bookings
                if link.active:
                    link.active = False
                    link.save(update_fields=["active"])
                res = materialize_for_schedule(sched)  # deletes future autogenerated due to inactive
                log.info("Webhook %s: deactivated link %s; res=%s", etype, link.id, res)
                audit_emit("webhook.subscription.deactivated", f"Schedule {sched.id} deactivated", context={"subscription_id": sub_id, "result": res})
            else:
                # for updates: just re-materialize to reflect any admin schedule edits already made
                res = materialize_for_schedule(sched)
                log.info("Webhook %s: refreshed sched %s; res=%s", etype, sched.id, res)
                audit_emit("webhook.subscription.updated", f"Schedule {sched.id} refreshed", context={"subscription_id": sub_id, "result": res})
        except Exception as e:
            log.exception("Webhook %s failed for sub %s: %s", etype, sub_id, e)
        return HttpResponse("ok")

    # Noise: ignore unhandled types but return 200
    log.debug("Unhandled Stripe event type: %s", etype)
    return HttpResponse("ok")
